MungeAndNotifyJob = Struct.new(:earl_id, :type, :email, :photocracy, :export_key)
class MungeAndNotifyJob

  def on_permanent_failure
    date_requested = DateTime.iso8601(export_key.split('_')[-2])
    IdeaMailer.deliver_export_failed([APP_CONFIG[:ERRORS_EMAIL], email], type, date_requested, photocracy)
  end

  # munges CSV file generated by pairwise to augment or remove the CSV
  # also notifies the user that their file is ready
  def perform
    SiteConfig.set_pairwise_credentials(photocracy)
    earl = Earl.find(earl_id)

    # make HTTP request to pairwise to get export data
    url = URI.parse("#{APP_CONFIG[:API_HOST]}/exports/#{export_key}")
    req = Net::HTTP::Get.new(url.path)
    # important to trigger basic HTTP Auth on pairwise
    req["Accept"] = "text/csv"
    req.basic_auth Question.user, Question.password
    res = Net::HTTP.start(url.host, url.port) { |http| http.request(req) }
    if res.code != "200"
      raise "Export URL returned response code of #{res.code} for #{url.to_s}"
    end
    csvdata = res.body.force_encoding('UTF-8')

    # for creating zlibed CSV at the end
    zoutput = Zlib::Deflate.new
    znewcsv = ''

    earl.munge_csv_data(csvdata, type).each do |row|
      znewcsv << zoutput.deflate(row)
    end
    znewcsv << zoutput.finish
    zoutput.close

    export_id = Export.connection.insert("INSERT INTO `exports` (`name`, `data`, `compressed`) VALUES (#{Export.connection.quote(export_key)}, #{Export.connection.quote(znewcsv)}, 1)".force_encoding('ASCII-8BIT'))
    Delayed::Job.enqueue DestroyOldExportJob.new(export_id), 20, 3.days.from_now
    url = "/export/#{export_key}"
    IdeaMailer.deliver_export_data_ready(email, url, photocracy)

    return true
  end
end
