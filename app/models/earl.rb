class Earl < ActiveRecord::Base
  @@reserved_names = ["questions", "question", 'about', 'privacy', 'tour', 'no_google_tracking', 'admin', 'abingo', 'earls', 'signup', 'sign_in', 'sign_out','clicks', 'fakequestion', 'photocracy', 'fotocracy']
  validates_presence_of :question_id, :on => :create, :message => "can't be blank"
  validates_presence_of :name, :on => :create, :message => "can't be blank"
  validates_length_of :welcome_message, :maximum=>350, :allow_nil => true, :allow_blank => true
  has_friendly_id :name, :use_slug => true, :reserved => @@reserved_names 
  has_attached_file :logo, :whiny_thumbnails => true, :styles => { :banner => "450x47>", :medium => "150x150>" }

  belongs_to :user
  
  def self.reserved_names
    @@reserved_names
  end

  # Triggers pairwise export of CSV
  # also inserts new delayed_job for munge_and_notify
  def export(options = {})
    type = options[:type]
    email = options[:email]
    @photocracy = options[:photocracy]
    SiteConfig.set_pairwise_credentials(@photocracy)

    @question = Question.find(self.question_id)

    redis_key = "export_filename_notification_#{self.question_id}_#{type}_#{Time.now.to_i}_#{rand(10)}"

    @question.post(:export, :type => type, :response_type => 'redis', :redis_key => redis_key)

    self.send_later :munge_and_notify, :type => type, :email => email, :photocracy => @photocracy, :redis_key => redis_key
  end

  # munges CSV file generated by pairwise to augment or remove the CSV
  # also notifies the user that their file is ready
  def munge_and_notify(options = {})
    type = options[:type]
    email = options[:email]
    redis_key = options[:redis_key]
    @photocracy = options[:photocracy]
    SiteConfig.set_pairwise_credentials(@photocracy)

    # delayed job doesn't like passing the user as parameter
    # so we do this manually
    current_user = User.find_by_email(email)

    r = Redis.new

    thekey, source_filename = r.blpop(redis_key, (60*60*3).to_s) #Timeout after 3 hours

    r.del(redis_key) # client is responsible for deleting key


    dest_filename= File.join(File.expand_path(Rails.root), "public", "system", "exports", 
           self.question_id.to_s, File.basename(source_filename))                

    FileUtils::mkdir_p(File.dirname(dest_filename))                              
          
    
    #Caching these to prevent repeated lookups for the same session, Hackish, but should be fine for background job
    @sessions = {}
    @url_alias = {}

    num_slugs = self.slugs.size
    FasterCSV.open(dest_filename, "w") do |csv|
      FasterCSV.foreach(source_filename, {:headers => :first_row, :return_headers => true}) do |row|

        if row.header_row?
          if @photocracy
            if type == 'votes'
              row << ['Winner Photo Name', 'Winner Photo Name']
              row << ['Loser Photo Name', 'Loser Photo Name']
            elsif type == 'non_votes'
              row << ['Left Photo Name', 'Left Photo Name']
              row << ['Right Photo Name', 'Right Photo Name']
            elsif type == 'ideas'
              row << ['Photo Name', 'Photo Name']
            end
          end

          case type
            when "votes", "non_votes"
              #We need this to look up SessionInfos, but the user doesn't need to see it
              row.delete('Session Identifier')

              row << ['Hashed IP Address', 'Hashed IP Address']
              row << ['URL Alias', 'URL Alias']
              if current_user.admin?
                row << ['Geolocation Info', 'Geolocation Info']
              end
          end
          csv << row
        else
          if @photocracy
            if    type == 'votes'
              p1 = Photo.find_by_id(row['Winner Text'])
              p2 = Photo.find_by_id(row['Loser Text'])
              row << [ 'Winner Photo Name', p1 ? p1.photo_name : 'N/A' ]
              row << [ 'Loser Photo Name',  p2 ? p2.photo_name : 'N/A' ]
            elsif type == 'non_votes'
              p1 = Photo.find_by_id(row['Left Choice Text'])
              p2 = Photo.find_by_id(row['Right Choice Text'])
              row << [ 'Left Photo Name',  p1 ? p1.photo_name : 'N/A' ]
              row << [ 'Right Photo Name', p2 ? p2.photo_name : 'N/A' ]
            elsif type == 'ideas'
              p1 = Photo.find_by_id(row['Idea Text'])
              row << [ 'Photo Name', p1 ? p1.photo_name : 'N/A' ]
            end
          end

          case type
            when "votes", "non_votes"

              sid = row['Session Identifier']
              row.delete('Session Identifier')

              user_session = @sessions[sid]
              if user_session.nil?
                user_session = SessionInfo.find_by_session_id(sid)
                @sessions[sid] = user_session
              end

              unless user_session.nil? #edge case, all appearances and votes after april 8 should have session info
                # Some marketplaces can be accessed via more than one url
                if num_slugs > 1
                  url_alias = @url_alias[sid]

                  if url_alias.nil?
                    max = 0
                    self.slugs.each do |slug|
                      num = user_session.clicks.count(:conditions => ['url like ?', '%' + slug.name + '%' ])

                      if num > max
                        url_alias = slug.name
                        max = num
                      end
                    end

                    @url_alias[sid] = url_alias
                  end
                else
                  url_alias = self.name
                end


                row << ['Hashed IP Address', Digest::MD5.hexdigest([user_session.ip_addr, IP_ADDR_HASH_SALT].join(""))]
                row << ['URL Alias', url_alias]
                if current_user.admin?
                  row << ['Geolocation Info', user_session.loc_info.to_s]
                end
              end
            end
            csv << row

        end
      end
    end
    
    File.send_at(3.days.from_now, :delete, dest_filename)
    url = "/system/exports/#{self.question_id}/#{File.basename(dest_filename)}"
    ::IdeaMailer.deliver_export_data_ready(email, url, @photocracy)

    dest_filename
  end
end
